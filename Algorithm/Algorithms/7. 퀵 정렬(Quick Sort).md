# **퀵 정렬**

**Abstract**

Quck Sort는 분할 정복 방법을 통해 주어진 배열을 정렬한다.

❗ `분할정복 : 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 방법.`

Quick Sort은 불안정 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다. 또한 Merge Sort와 달리 Quick Sort는 배열을 비균등하게 분할한다.

**Process (Ascending)**

1. 배열 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗(pivot)이라고 한다.

2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다. 이렇게 배열을 둘로 나누는 것을 분할(Divide)라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.

3. 분할된 두 개의 작은 배열에 대해 재귀적으로 이 과정을 반복한다.

`재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.`


**Code**

```c++
void quickSort(int arr[], int start, int end) {
	if (start >= end) return; // 원소가 1개인경우 리턴

	int pivot = start;
	int i = start + 1;
	int j = end;

	while (i <= j) { // i와 j가 엇갈리기 전까지
		while (arr[i] <= arr[pivot] && i <= end) { // i는 start+1 부터 pivot값보다 큰 값을 찾을때까지 동작
			i++;
		}
		while (arr[j] >= arr[pivot] && j > start) { // j는 end 부터pivot값보다 작은 값을 찾을때 까지
			j--;
		}

		if (i > j) { // 둘이 엇갈렸으면
			swap(arr[pivot], arr[j]); // pivot값과 j위치값을 교환한다.
		}
		else { // 아니면 i와 j위치값을 교환한다.
			swap(arr[i], arr[j]);
		}
	}
	// j위치의 값은 정렬됐다.
	quickSort(arr, start, j - 1); // j위치를 중심으로 왼쪽
	quickSort(arr, j + 1, end); // j위치를 중심으로 오른쪽
								// 으로 분할하여 재귀시킨다.
	return;
}
```

**시간복잡도**

**최선의 경우(Best cases) : T(n) = O(nlog₂n)**

비교 횟수 (log₂n)

레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k) 했을 때, n=2^3의 경우, 2^3 -> 2^2 -> 2^1 -> 2^0 순으로 줄어들어 순환 호출의 깊이가 3임을 알 수 있다.

![img](./Pictures/퀵소트1.jpg)

이것을 일반화하면 n=2^k의 경우, **k(k=log₂n)** 임을 알 수 있다.

각 순환 호출 단계의 비교 연산 (n)

각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 **평균 n번** 정도의 비교가 이루어진다.

따라서, 최선의 시간복잡도는 순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = nlog₂n 가 된다. 이동 횟수는 비교 횟수보다 적으므로 무시할 수 있다.



**최악의 경우(Worst cases) : T(n) = O(n^2)**

최악의 경우는 정렬하고자 하는 배열이 오름차순 정렬되어있거나 내림차순 정렬되어있는 경우다.

비교 횟수 (n)

![img](./Pictures/퀵소트2.jpg)

레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k)했을 때, 순환 호출의 깊이는 **n** 임을 알 수 있다.

각 순환 호출 단계의 비교 연산 (n)

각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 **평균 n번 ** 정도의 비교가 이루어진다.

따라서, 최악의 시간복잡도는 순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = n^2 다. 이동 횟수는 비교 횟수보다 적으므로 무시할 수 있다.

`평균의 경우(Average cases) : T(n) = O(nlog₂n)`

**공간복잡도**

주어진 배열 안에서 교환을 통해, 정렬이 수행되므로 O(n) 이다.

**장점**

* 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
* 제자리 정렬이다.

**단점**

* **불안정 정렬(Unstable Sort)** 이다.
* 정렬된 배열에 대해서는 Quick Sort의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

**Conclusion**

평균적으로 가장 빠른 정렬 알고리즘. JAVA에서 Arrays.sort() 내부적으로도 Dual Pivot Quick Sort로 구현되어 있을 정도로 효율적인 알고리즘이고, 기술 면접에서 정말 빈번하게 나오는 주제이므로 반드시 숙지하자