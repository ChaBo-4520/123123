# **선택정렬**

**Abstract**

Selection Sort는 Bubble Sort과 유사한 알고리즘으로, <u>**해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘**</u>이다.

Selection Sort는 배열에서 <u>**해당 자리를 선택하고 그 자리에 오는 값을 찾는 것**</u>

**Process (Ascending)**

1. 주어진 범위에서 최소값을 찾는다.

2. 그 값을 주어진 범위의 가장 처음에 위치한 원소와 바꾼다.

3. 1회전 이후, 가장 앞의 원소가 정렬되므로 그 다음원소부터 범위가 시작된다.

**Code**

```c++
void selectionSort(int arr[]) {
	// 선택정렬
	int indexMin; // 최소값의 위치
	for (int i = 0; i < arrlength; i++) { // 이번회전에 정렬될 번호
		indexMin = i;
		for (int j = 0 + i; j < arrlength; j++) {
			if (arr[indexMin] > arr[j]) indexMin = j; // 최소값을 찾는 과정
		}
		uSwap(&arr[indexMin], &arr[i]);
	}
	return;
}
```

**시간복잡도**

데이터의 개수가 n개라고 했을 때,

첫 번째 회전에서의 비교횟수 : 1 ~ (n-1) => n-1

두 번째 회전에서의 비교횟수 : 2 ~ (n-1) => n-2

...

총 비교횟수 : (n-1) + (n-2) + .... + 2 + 1 => n(n-1)/2

비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 배열을 정렬하는데 O(n^2) 만큼의 시간이 걸린다. 최선, 평균, 최악의 경우 시간복잡도는 **O(n^2)** 으로 동일하다.

**공간복잡도**

주어진 배열 안에서 교환을 통해, 정렬이 수행되므로 O(n) 이다.

**장점**

* Bubble sort와 마찬가지로 알고리즘이 단순하다.

* 정렬을 위한 비교 횟수는 많지만, Bubble Sort에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다.

* Bubble Sort와 마찬가지로 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. => 제자리 정렬(in-place sorting)

**단점**

* 시간복잡도가 **O(n^2)**으로, 비효율적이다.

* **불안정 정렬(Unstable Sort)** 이다.

